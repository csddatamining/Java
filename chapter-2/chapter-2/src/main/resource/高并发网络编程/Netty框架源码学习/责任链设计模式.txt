设计模式-责任链模式（Chain of Responsibility Pattern）
为请求创建了一个处理对象的链。
发起请求和具体处理请求的过程进行解耦：职责链链上的处理者负责处理请求，客户只需将请求发送到职责链上即可，
无须关心请求的处理细节和请求的传递

Netty中的ChannelPipeline责任链
Pipeline管道保存了通道所有处理器的信息
创建新channel时自动创建一个专有的pipeline
入站事件和出站操作会调用pipeline上的处理器

一、入站事件和出站事件是什么意思？
入站事件和出站事件
入站事件：通常指I/O线程生成了入站数据。
通俗理解：从socket底层自己网上冒上来的时间都是入站
比如EventLoop收到selector的OP_READ时间，入站处理器调用socketChannel.read(ByteBuffer)
接收到数据后，这将导致通道的ChannelPipeline中包含的下一个中的channelRead方法被调用

出站事件：经常指I/O线程执行实际的输出操作
通俗理解：向主动往socket底层操作的时间都是出站
比如bind方法用意是请求sever socket绑定到给定的SocketAddress，这将导致通道的
ChannelPipeline中包含的下一个出站处理器中的bind方法被调用

二、Pipeline中的handler处理器是什么，有什么作用
ChannelHandler：用于处理I/O事件或拦截I/O操作，并转发到ChannelPipeline中的下一个处理器
这个顶级接口定义功能很弱，实际使用会去实现下面两大子接口：
处理入站I/O事件的ChannelInboundHandler、处理出站I/O操作的ChannelOutboundHandler

适配器类：为了开发方便，避免所欲handler去实现一遍接口方法，Netty提供了简单的实现类：
ChannelInboundHandlerAdapter处理入站I/O事件
ChannelOutboundHandlerAdapter来处理出站I/O操作
ChannelDuplexHandler来支持同事处理入站和出站事件

ChannelHandlerContext：实际存储在Pipeline中的对象并非ChannelHandler，而是上下文对象
将handler，包裹在上下文对象中，通过上下文对象与它所属的ChannelPipeline交互，向上或向下传递事件
或者修改pipeline都是通过上下文对象



三、Pipeline如何维护channel的
ChannelPipeline是线程安全的，CHannelHandler可以在任何时候添加或删除
例如，你可以在即将交换敏感信息时插入加密处理程序，并在交换后删除它
一般操作，初始化的时候增加进去，较少删除。

handle的执行
