Java中锁的概念
自旋锁：为了不放弃CPU执行时间，循环的使用CAS技术对数据尝试进行更新，直至成功
悲观锁：假定会发生并发冲突，同步所有对数据的相关操作，从读数据就开始上锁
乐观锁：假定没有冲突，在修改数据时如果发现数据和之前获取的不一致，则读最新数据，修改后重试修改

独享锁（写）：给资源加上写锁，线程可以修改资源，其他线程不能再加锁；（单写）
共享锁（读）：给资源加上读锁后只能读不能改，其他线程也只能加读锁，不能加写锁（多读）

可重入锁、不可重入锁：线程拿到一把锁之后，可以自由进入同一把锁同步的其他代码
公平锁、非公平锁：争抢锁的顺序，如果是按先来后到，则为公平

几种重要的锁实现方式：synchronized、ReentrantLock、ReentrantReadWriteLock

同步关键字synchronized
属于最基本的线程通信机制，基于对象监视器实现的
Java中的每个对象都与一个监视器相关联，一个线程可以锁定或解锁
一次只有一个线程可以锁定监视器
试图锁定该监视器的任何其他线程都会被阻塞

特性：可重入、独享、悲观锁

锁的范围：类锁、对象锁、锁消除、锁粗化
同步关键字，不仅实现同步，根据JVM规定还能保证可见性（读取最新主内存数据，结束后写入主内存）

同步关键字加锁原理
默认情况下JVM锁会经历：偏向锁->轻量级锁->重量级锁

对象-》开启/不开启偏向锁
偏向锁第一次有用，出现过争用就没用了
偏向锁，本质就是无锁，如果没有发生过任何多线程争抢锁的情况，JVM就认为是单线程，无需做同步

重量级锁-监视器
修改Mark word如果失败，回自旋CAS一定次数，该次数可以通过参数配置
超过次数，扔未抢到锁，则锁升级为重量级锁，进入阻塞
monitor也叫管程，一个对象对应一个monitor

Lock的核心API
lock    获取锁的方法，若锁被其他线程后去，则等待（阻塞）
lockInterruptibly  在锁的获取过程中可以中断当前线程
tryLock     尝试非阻塞地获取锁，立即返回
unlock      释放锁

ReentrantLock
独享锁；支持公平锁、非公平锁两种模式；可重入锁

