一、class文件内容
class文件包含JAVA程序执行的字节码；数据严格按照格式紧凑排列在class文件中的二进制流，中间无任何分隔符；
文件开头有一个0xcafebabe(16进制)特殊的一个标志

二、JVM运行时数据区
1.线程共享部分：方法区、堆内存
2.线程独占部分：虚拟机栈、本地方法栈、程序计数器

线程独占：每个线程有独立的空间，随线程生命周期而创建和销毁
线程共享：所有线程能访问这块内存数据，随虚拟机或者GC创建和销毁

方法区：存储加载的类信息、常量、静态变量、变异后的代码等数据
虚拟机规范中这个是一个逻辑区划，具体实现根据不同虚拟机来实现。
堆内存：分为老年代、新生代。JVM启动时床架你，存放对象的实例。垃圾回收主要就是管理堆内存，如果满了，就会出现OutOfMemoryError。
虚拟机栈：每个线程都在这个空间有一个私有的空间。
    线程栈由多个栈帧组成。
    一个线程会执行一个或多个方法，一个方法对应一个栈桢
    栈桢内容包含：局部变量表、操作数栈、动态链接、方法返回地址、附加信息等。
    栈内存默认最大是1M，超出抛StackOverflowError
本地方法栈：为虚拟机使用Native本地方法而准备的。
程序计数器：记录当前线程执行字节码的位置，存储的是字节码指令地址，如果执行Native方法，则计数器值为空。

三、查看class文件内容
javap -v Demo1.class > Demo1.txt

四、内存屏障和CPU缓存
cpu分三级缓存:
L1 Cache(一级缓存)，分为数据缓存和指令缓存。容量通常在32-4096KB
L2 Cache(二级缓存)，由于L1级高速缓存的容量限制，又放置了高速存储器
L3 Cache(三级缓存)，进一步降低内存延迟，一般是多核共享一个L3缓存

缓存同步协议MESI协议
规定每条缓存有个状态为，同事定义下面四个状态：
修改态
专有态
共享态
无效态

CPU性能优化手段-运行时指令重排
指令重排场景：当CPU写缓存时发现缓存区块正在被其他CPU占用，为提高CPU处理性能，可能将后面的读缓存命令优先运行

遵循as-if-serial语义
指不管如何重排，程序的执行结果不能被改变。编译器，runtime和处理器都必须遵守as-if-serial语义

两个问题：
1.CPU高速缓存下有一个问题：
缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步。
在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的
2.CPU执行指令重排序优化下有一个问题：
虽然遵循as-if-serial语义，单仅在单CPU自己执行的情况下能保证结果正确
多核多线程中，指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误。

内存屏障
处理器提供了两个内存屏障指令（Memory Barrier）用于解决上述两个问题：

1.写内存屏障（Store Memory Barrier）：在指令后插入Store Barrier，能让写入缓存中的最新数据写入主内存，让其他线程可见。
强制写入主内存，这种显示调用，CPU就不会因为性能考虑而对指令重排
2.读内存屏障（Load Memory Barrier）：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据。
强制读取主内存内容，让CPU缓存与主内存保持一致，避免缓存导致的一致性问题。
