Java中锁的概念
自旋锁：为了不放弃CPU执行时间，循环的使用CAS技术对数据尝试进行更新，直至成功
悲观锁：假定会发生并发冲突，同步所有对数据的相关操作，从读数据就开始上锁
乐观锁：假定没有冲突，在修改数据时如果发现数据和之前获取的不一致，则读最新数据，修改后重试修改

独享锁（写）：给资源加上写锁，线程可以修改资源，其他线程不能再加锁；（单写）
共享锁（读）：给资源加上读锁后只能读不能改，其他线程也只能加读锁，不能加写锁（多读）

可重入锁、不可重入锁：线程拿到一把锁之后，可以自由进入同一把锁同步的其他代码
公平锁、非公平锁：争抢锁的顺序，如果是按先来后到，则为公平

几种重要的锁实现方式：synchronized、ReentrantLock、ReentrantReadWriteLock

同步关键字synchronized
属于最基本的线程通信机制，基于对象监视器实现的
Java中的每个对象都与一个监视器相关联，一个线程可以锁定或解锁
一次只有一个线程可以锁定监视器
试图锁定该监视器的任何其他线程都会被阻塞

特性：可重入、独享、悲观锁

锁的范围：类锁、对象锁、锁消除、锁粗化
同步关键字，不仅实现同步，根据JVM规定还能保证可见性（读取最新主内存数据，结束后写入主内存）

同步关键字加锁原理
默认情况下JVM锁会经历：偏向锁->轻量级锁->重量级锁

对象-》开启/不开启偏向锁
偏向锁第一次有用，出现过争用就没用了
偏向锁，本质就是无锁，如果没有发生过任何多线程争抢锁的情况，JVM就认为是单线程，无需做同步

重量级锁-监视器
修改Mark word如果失败，回自旋CAS一定次数，该次数可以通过参数配置
超过次数，扔未抢到锁，则锁升级为重量级锁，进入阻塞
monitor也叫管程，一个对象对应一个monitor

Lock的核心API
lock    获取锁的方法，若锁被其他线程后去，则等待（阻塞）
lockInterruptibly  在锁的获取过程中可以中断当前线程
tryLock     尝试非阻塞地获取锁，立即返回
unlock      释放锁

ReentrantLock
独享锁；支持公平锁、非公平锁两种模式；可重入锁

ReadWriteLock
维护一对关联锁，一个用于只读操作，一个用于写入；读锁可以由多个线程同时持有，写锁是排他的
适合读取线程比写入线程多的场景，改进互斥锁的性能，示例场景：缓存组件、集合的并发线程安全性改造
锁降级指的是写锁降级成为读锁。把持住当前拥有的写锁的同时，再获取到读锁，随后释放写锁的过程
写锁是线程独占，读锁是共享，所以写->读是升级（读->写，是不能实现的）

Condition
用于替代wait/notify
Object中的wait(),notify(),notifyAll()方法是和synchronized配合使用的，可以唤醒一个或者全部（单个等待集）
Condition是需要和Lock配合使用的，提供多个等待集合，更精确的控制（底层是park/unpark机制）


